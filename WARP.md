# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Project Overview

Fluidity is a secure HTTP/HTTPS/WebSocket tunneling solution with mTLS authentication. It tunnels traffic through restrictive firewalls using a client-server architecture with mutual TLS authentication between a local agent and cloud-hosted server.

**Stack**: Go 1.21+, Docker, AWS ECS Fargate, Lambda  
**Container Size**: ~44MB Alpine containers  
**Security**: mTLS with private CA

## Common Commands

### Building

```bash
# Build all binaries (agent + server)
./scripts/build-core.sh

# Build specific component
./scripts/build-core.sh --agent
./scripts/build-core.sh --server

# Build for Linux (required for Docker/AWS)
./scripts/build-core.sh --linux
./scripts/build-core.sh --server --linux

# Build Lambda functions
./scripts/build-lambdas.sh

# Build Docker images
docker build -f deployments/server/Dockerfile -t fluidity-server .
docker build -f deployments/agent/Dockerfile -t fluidity-agent .
```

### Testing

```bash
# Run all tests
go test ./... -v

# Run with coverage
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out

# Run specific package tests
go test -v ./internal/core/agent/...
go test -v ./internal/core/server/...
go test -v ./internal/shared/protocol/...

# Run specific test
go test -v -run TestClientConnect ./internal/core/agent/...
```

### Certificate Management

```bash
# Generate mTLS certificates (required for first-time setup)
./scripts/manage-certs.sh

# Certificates are stored in ./certs/
# - ca.crt, ca.key (CA certificate and key)
# - server.crt, server.key (Server certificate)
# - client.crt, client.key (Client certificate)
```

### Local Development

```bash
# Run server locally (Terminal 1)
./build/fluidity-server -config configs/server.local.yaml

# Run agent locally (Terminal 2)
./build/fluidity-agent -config configs/agent.local.yaml

# Test with curl
curl -x http://127.0.0.1:8080 http://example.com
```

### Deployment

```bash
# Deploy Fargate server via CloudFormation
./scripts/deploy-fluidity.sh fargate deploy

# Deploy Lambda control plane (Wake/Sleep/Kill)
./scripts/deploy-fluidity.sh lambda deploy

# Clean up deployment
./scripts/deploy-fluidity.sh fargate destroy
./scripts/deploy-fluidity.sh lambda destroy

# Wake server via API Gateway
curl -X POST https://<api-id>.execute-api.us-east-1.amazonaws.com/prod/wake

# Kill server via API Gateway
curl -X POST https://<api-id>.execute-api.us-east-1.amazonaws.com/prod/kill
```

### Docker Operations

```bash
# Run server container
docker run --rm -p 8443:8443 -v $(pwd)/certs:/root/certs:ro fluidity-server

# Run agent container
docker run --rm -p 8080:8080 -v $(pwd)/certs:/root/certs:ro fluidity-agent

# View logs
docker logs <container-id>
```

## Architecture Overview

### Client-Server Model

**Agent** (Local):
- HTTP proxy server listening on localhost:8080
- mTLS client connecting to server via WebSocket
- Calls Wake Lambda on startup, Kill on shutdown (when lifecycle enabled)
- Auto-reconnects with exponential backoff on connection loss

**Server** (Cloud/ECS Fargate):
- mTLS server listening on port 8443
- HTTP client for making requests to target websites
- Emits CloudWatch metrics (ActiveConnections, LastActivityEpochSeconds)
- Health check endpoint on port 8080

**Lambda Control Plane** (Optional, for cost optimization):
- **Wake**: Starts ECS service (DesiredCount=1) via API Gateway
- **Sleep**: Auto-scales down when idle (EventBridge, every 5 min)
- **Kill**: Immediate shutdown via API Gateway

### Protocol Design

The tunnel uses a JSON-based envelope protocol over TLS 1.3:

```go
type Envelope struct {
    Type    string      `json:"type"`    // Message type identifier
    Payload interface{} `json:"payload"` // Type-specific payload
}
```

**Message Types**:
- `http_request` / `http_response`: Standard HTTP tunneling
- `connect_open` / `connect_ack` / `connect_data` / `connect_close`: HTTPS CONNECT tunneling
- `ws_open` / `ws_ack` / `ws_message` / `ws_close`: WebSocket tunneling

Each request/connection gets a unique ID generated by `protocol.GenerateID()` for request-response correlation.

### Code Organization

```
cmd/
├── core/
│   ├── agent/main.go    # Agent entry point with lifecycle integration
│   └── server/main.go   # Server entry point with health checks
└── lambdas/
    ├── wake/main.go     # Wake Lambda handler
    ├── sleep/main.go    # Sleep Lambda handler (metrics-based)
    └── kill/main.go     # Kill Lambda handler

internal/
├── core/
│   ├── agent/
│   │   ├── agent.go     # Tunnel client with auto-reconnect
│   │   ├── proxy.go     # HTTP/HTTPS proxy server
│   │   └── lifecycle/   # Wake/Kill API integration
│   └── server/
│       ├── server.go    # mTLS server with connection handling
│       ├── handler.go   # Request forwarding logic
│       └── metrics/     # CloudWatch metrics emission
├── lambdas/
│   ├── wake/            # ECS service wake logic
│   ├── sleep/           # Idle detection and scale-down
│   └── kill/            # Immediate shutdown
└── shared/
    ├── protocol/        # Message definitions and serialization
    ├── tls/             # mTLS utilities (client/server config)
    ├── config/          # YAML configuration loading
    ├── logging/         # Structured logging (logrus)
    ├── circuitbreaker/  # Circuit breaker pattern
    ├── retry/           # Exponential backoff retry
    └── secretsmanager/  # AWS Secrets Manager integration
```

## Key Implementation Details

### Connection Lifecycle

**Agent Connection Flow**:
1. Agent calls Wake Lambda if lifecycle enabled
2. Establishes mTLS connection to server (auto-retry for 90s)
3. Starts handling proxy requests
4. On disconnect: auto-reconnects with exponential backoff (5s intervals)
5. On shutdown: calls Kill Lambda if lifecycle enabled

**Server Connection Handling**:
1. Accept mTLS connection (validates client certificate)
2. Spawn goroutine for each connection
3. Decode incoming requests via JSON decoder
4. Route based on Envelope.Type
5. Track active connections for metrics

### Request Flow

1. **Browser → Agent Proxy** (port 8080): HTTP/HTTPS CONNECT request
2. **Agent → Tunnel Client**: Convert to protocol.Request with unique ID
3. **Tunnel → Server**: Send JSON-encoded Envelope over mTLS
4. **Server → Target Website**: Make HTTP request via stdlib client
5. **Server → Tunnel**: Return protocol.Response with same ID
6. **Agent → Browser**: Forward response back to browser

### Reliability Patterns

**Circuit Breaker** (`internal/shared/circuitbreaker/`):
- Protects against cascading failures to target websites
- States: Closed → Open (5 failures) → Half-Open (30s timeout) → Closed
- Used in server's HTTP client for target requests

**Retry Logic** (`internal/shared/retry/`):
- Exponential backoff: 1s → 2s → 4s (max 10s)
- Max 3 attempts
- Used for transient network failures

**Auto-Reconnection** (agent):
- Retry interval: 5s
- Max duration: 90s (after wake call)
- Context-based cancellation

### TLS Configuration

**mTLS Requirements**:
- TLS 1.3 minimum
- Mutual authentication (client and server certificates)
- Private CA validation (no InsecureSkipVerify)

**Certificate Loading Order** (Server):
1. Environment variables (CERT_PEM, KEY_PEM, CA_PEM) from ECS Secrets
2. AWS Secrets Manager (if `use_secrets_manager: true`)
3. Local files (./certs/)

**Certificate Loading Order** (Agent):
1. AWS Secrets Manager (if `use_secrets_manager: true`)
2. Local files (./certs/)

### Configuration Files

**Agent** (`configs/agent.yaml`):
- `server_ip`: Fargate server public IP
- `server_port`: 8443 (mTLS)
- `local_proxy_port`: 8080
- `cert_file`, `key_file`, `ca_cert_file`: Local certificate paths
- `use_secrets_manager`: Boolean for AWS Secrets Manager
- `log_level`: debug/info/warn/error

**Server** (`configs/server.yaml`):
- `listen_addr`: "0.0.0.0"
- `listen_port`: 8443
- `max_connections`: 100
- `emit_metrics`: Boolean for CloudWatch metrics
- `metrics_interval`: "60s"
- `use_secrets_manager`: Boolean for AWS Secrets Manager
- `log_level`: debug/info/warn/error

## Development Workflow

### Adding New Protocol Message Types

1. Define message struct in `internal/shared/protocol/protocol.go`
2. Add envelope type constant (e.g., "new_message_type")
3. Add handler in `internal/core/server/handler.go` (`handleEnvelope`)
4. Add sender in `internal/core/agent/agent.go`
5. Update tests in `internal/shared/protocol/protocol_test.go`

### Testing Strategy

**3-Tier Testing** (75+ tests, ~77% coverage):
- **Unit Tests**: Individual component testing with mocks (17 tests)
- **Integration Tests**: Multi-component workflows with real dependencies (30+ tests)
- **E2E Tests**: Full system validation, client → agent → server → target (6 tests)

**Testing Patterns**:
- Use `context.Context` for timeouts and cancellation
- Mock external dependencies (AWS SDK, HTTP clients)
- Test both success and failure paths
- Verify certificate validation (reject invalid certs)

### Common Development Tasks

**Adding a New Lambda**:
1. Create handler in `cmd/lambdas/<name>/main.go`
2. Implement logic in `internal/lambdas/<name>/`
3. Add build target in `scripts/build-lambdas.sh`
4. Add CloudFormation resource in `deployments/cloudformation/lambda.yaml`
5. Add unit tests in `internal/lambdas/<name>/<name>_test.go`

**Modifying Certificate Handling**:
- Changes to `internal/shared/tls/tls.go` affect both agent and server
- Always test with valid and invalid certificates
- Verify mTLS handshake succeeds (check TLS 1.3, cipher suite in logs)
- Test certificate rotation (regenerate certs, restart)

**Adding CloudWatch Metrics**:
1. Update `internal/core/server/metrics/emitter.go`
2. Emit via `PutMetricData` (namespace: "Fluidity")
3. Update Sleep Lambda to consume new metrics
4. Add CloudWatch alarm in CloudFormation if needed

## Platform Notes

**Windows Development**:
- **WSL (Windows Subsystem for Linux) is required** for all bash scripts
- Run `bash scripts/setup-prereq-ubuntu.sh` in WSL to install dependencies
- Build commands must be run in WSL (not PowerShell/CMD)
- Agent can run on Windows after building in WSL

**Docker Desktop**:
- Required for containerized testing and AWS deployments
- Ensure WSL 2 backend is enabled on Windows

**AWS CLI**:
- v2 required for deployment scripts
- Configure credentials: `aws configure`
- Default region should be set (e.g., us-east-1)

## Security Considerations

### What NOT to Log

- No credentials (API keys, tokens, passwords)
- No full URLs (only domain/host)
- No POST/PUT body contents
- No query parameters with sensitive data

### Certificate Management

- CA private key (`ca.key`) should be stored securely (not committed)
- Certificates have 2-year validity (rotate quarterly recommended)
- Use AWS Secrets Manager for production deployments
- Never commit certificates to git (listed in .gitignore)

### Network Security

- Fargate Security Group: Restrict to known IPs if possible
- API Gateway endpoints: Should use API keys or IAM auth (currently unprotected)
- VPC Flow Logs: Enable for production monitoring

## Troubleshooting

### Connection Issues

**Agent can't connect to server**:
- Verify server is running: `aws ecs describe-services --cluster fluidity --services server`
- Check agent config has correct server IP
- Verify certificates: `openssl x509 -in ./certs/client.crt -noout -text`
- Check Security Group allows inbound on port 8443

**TLS handshake failures**:
- Enable TLS debug logging: Set `GODEBUG=tls13=1` before running
- Verify ServerName matches certificate CN (agent.go line 75)
- Check certificate chain: CA → Server/Client certificates

### Performance Issues

**High latency**:
- Check CloudWatch metrics for ActiveConnections
- Increase Fargate CPU/memory if needed (deployments/cloudformation/fargate.yaml)
- Verify connection pooling is working (server.go)

**Memory leaks**:
- Check for goroutine leaks with pprof
- Verify channels are being closed in agent/server handlers
- Monitor via CloudWatch Container Insights

### Deployment Issues

**CloudFormation stack fails**:
- Check CloudWatch Logs for stack events
- Verify IAM permissions for Lambda/ECS
- Ensure ECR image exists and is tagged correctly
- Check base64 encoding of certificates in params

**Lambda timeout**:
- Increase timeout in CloudFormation template (default 30s)
- Check IAM permissions for ECS API calls
- Verify VPC configuration if using private subnets
